'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var coreClient = require('@azure-rest/core-client');
var logger$1 = require('@azure/logger');
var corePaging = require('@azure/core-paging');

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const logger = logger$1.createClientLogger("ai-content-safety");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Initialize a new instance of `ContentSafetyClient`
 * @param endpoint - Supported Cognitive Services endpoints (protocol and hostname, for example:
 * https://<resource-name>.cognitiveservices.azure.com).
 * @param credentials - uniquely identify client credential
 * @param options - the parameter for all optional parameters
 */
function createClient(endpoint, credentials, options = {}) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const baseUrl = (_a = options.baseUrl) !== null && _a !== void 0 ? _a : `${endpoint}/contentsafety`;
    options.apiVersion = (_b = options.apiVersion) !== null && _b !== void 0 ? _b : "2023-10-01";
    const userAgentInfo = `azsdk-js-ai-content-safety-rest/1.0.0`;
    const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
        ? `${options.userAgentOptions.userAgentPrefix} ${userAgentInfo}`
        : `${userAgentInfo}`;
    options = Object.assign(Object.assign({}, options), { userAgentOptions: {
            userAgentPrefix,
        }, loggingOptions: {
            logger: (_d = (_c = options.loggingOptions) === null || _c === void 0 ? void 0 : _c.logger) !== null && _d !== void 0 ? _d : logger.info,
        }, credentials: {
            scopes: (_f = (_e = options.credentials) === null || _e === void 0 ? void 0 : _e.scopes) !== null && _f !== void 0 ? _f : ["https://cognitiveservices.azure.com/.default"],
            apiKeyHeaderName: (_h = (_g = options.credentials) === null || _g === void 0 ? void 0 : _g.apiKeyHeaderName) !== null && _h !== void 0 ? _h : "Ocp-Apim-Subscription-Key",
        } });
    const client = coreClient.getClient(baseUrl, credentials, options);
    return client;
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const responseMap = {
    "POST /text:analyze": ["200"],
    "POST /image:analyze": ["200"],
    "GET /text/blocklists/{blocklistName}": ["200"],
    "PATCH /text/blocklists/{blocklistName}": ["200", "201"],
    "DELETE /text/blocklists/{blocklistName}": ["204"],
    "GET /text/blocklists": ["200"],
    "POST /text/blocklists/{blocklistName}:addOrUpdateBlocklistItems": ["200"],
    "POST /text/blocklists/{blocklistName}:removeBlocklistItems": ["204"],
    "GET /text/blocklists/{blocklistName}/blocklistItems/{blocklistItemId}": ["200"],
    "GET /text/blocklists/{blocklistName}/blocklistItems": ["200"],
};
function isUnexpected(response) {
    const lroOriginal = response.headers["x-ms-original-url"];
    const url = new URL(lroOriginal !== null && lroOriginal !== void 0 ? lroOriginal : response.request.url);
    const method = response.request.method;
    let pathDetails = responseMap[`${method} ${url.pathname}`];
    if (!pathDetails) {
        pathDetails = getParametrizedPathSuccess(method, url.pathname);
    }
    return !pathDetails.includes(response.status);
}
function getParametrizedPathSuccess(method, path) {
    var _a, _b, _c, _d;
    const pathParts = path.split("/");
    // Traverse list to match the longest candidate
    // matchedLen: the length of candidate path
    // matchedValue: the matched status code array
    let matchedLen = -1, matchedValue = [];
    // Iterate the responseMap to find a match
    for (const [key, value] of Object.entries(responseMap)) {
        // Extracting the path from the map key which is in format
        // GET /path/foo
        if (!key.startsWith(method)) {
            continue;
        }
        const candidatePath = getPathFromMapKey(key);
        // Get each part of the url path
        const candidateParts = candidatePath.split("/");
        // track if we have found a match to return the values found.
        let found = true;
        for (let i = candidateParts.length - 1, j = pathParts.length - 1; i >= 1 && j >= 1; i--, j--) {
            if (((_a = candidateParts[i]) === null || _a === void 0 ? void 0 : _a.startsWith("{")) && ((_b = candidateParts[i]) === null || _b === void 0 ? void 0 : _b.indexOf("}")) !== -1) {
                const start = candidateParts[i].indexOf("}") + 1, end = (_c = candidateParts[i]) === null || _c === void 0 ? void 0 : _c.length;
                // If the current part of the candidate is a "template" part
                // Try to use the suffix of pattern to match the path
                // {guid} ==> $
                // {guid}:export ==> :export$
                const isMatched = new RegExp(`${(_d = candidateParts[i]) === null || _d === void 0 ? void 0 : _d.slice(start, end)}`).test(pathParts[j] || "");
                if (!isMatched) {
                    found = false;
                    break;
                }
                continue;
            }
            // If the candidate part is not a template and
            // the parts don't match mark the candidate as not found
            // to move on with the next candidate path.
            if (candidateParts[i] !== pathParts[j]) {
                found = false;
                break;
            }
        }
        // We finished evaluating the current candidate parts
        // Update the matched value if and only if we found the longer pattern
        if (found && candidatePath.length > matchedLen) {
            matchedLen = candidatePath.length;
            matchedValue = value;
        }
    }
    return matchedValue;
}
function getPathFromMapKey(mapKey) {
    const pathStart = mapKey.indexOf("/");
    return mapKey.slice(pathStart);
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Helper to paginate results from an initial response that follows the specification of Autorest `x-ms-pageable` extension
 * @param client - Client to use for sending the next page requests
 * @param initialResponse - Initial response containing the nextLink and current page of elements
 * @param customGetPage - Optional - Function to define how to extract the page and next link to be used to paginate the results
 * @returns - PagedAsyncIterableIterator to iterate the elements
 */
function paginate(client, initialResponse, options = {}) {
    let firstRun = true;
    const itemName = "value";
    const nextLinkName = "nextLink";
    const { customGetPage } = options;
    const pagedResult = {
        firstPageLink: "",
        getPage: typeof customGetPage === "function"
            ? customGetPage
            : async (pageLink) => {
                const result = firstRun ? initialResponse : await client.pathUnchecked(pageLink).get();
                firstRun = false;
                checkPagingRequest(result);
                const nextLink = getNextLink(result.body, nextLinkName);
                const values = getElements(result.body, itemName);
                return {
                    page: values,
                    nextPageLink: nextLink,
                };
            },
    };
    return corePaging.getPagedAsyncIterator(pagedResult);
}
/**
 * Gets for the value of nextLink in the body
 */
function getNextLink(body, nextLinkName) {
    if (!nextLinkName) {
        return undefined;
    }
    const nextLink = body[nextLinkName];
    if (typeof nextLink !== "string" && typeof nextLink !== "undefined") {
        throw new Error(`Body Property ${nextLinkName} should be a string or undefined`);
    }
    return nextLink;
}
/**
 * Gets the elements of the current request in the body.
 */
function getElements(body, itemName) {
    const value = body[itemName];
    // value has to be an array according to the x-ms-pageable extension.
    // The fact that this must be an array is used above to calculate the
    // type of elements in the page in PaginateReturn
    if (!Array.isArray(value)) {
        throw new Error(`Couldn't paginate response\n Body doesn't contain an array property with name: ${itemName}`);
    }
    return value !== null && value !== void 0 ? value : [];
}
/**
 * Checks if a request failed
 */
function checkPagingRequest(response) {
    const Http2xxStatusCodes = ["200", "201", "202", "203", "204", "205", "206", "207", "208", "226"];
    if (!Http2xxStatusCodes.includes(response.status)) {
        throw coreClient.createRestError(`Pagination failed with unexpected statusCode ${response.status}`, response);
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

exports.default = createClient;
exports.isUnexpected = isUnexpected;
exports.paginate = paginate;
//# sourceMappingURL=index.js.map
